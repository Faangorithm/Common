# Today We Learned

## 2019-09-27(Fri)
### 16 (Two pointer)
#### 윤수 
- 요약 : 하나의 고정점을 찾는 3개의 포인터 이동 문제다.  
투 포인터 문제는 각각의 포인터를 왼쪽끝과 오른쪽끝에서 시작해 한 스텝에 무조건 둘 중 하나의 포인터를 이동시켜 더 작은 범위를 만들어야 한다.   
정렬을 함으로써 왼쪽 끝과 오른쪽 끝을 포인터로 시작할 수 있게된다.   
3개의 자유 변수를 1개의 자유 변수, 1개의 커지는 변수(왼쪽 포인터), 1개의 작아지는 변수(오른쪽 포인터)로 제약을 걸게 되면 O(n^2)로 풀 수 있다.   

#### 석호

문제 요약: target이 주어지고 세 수의 합이 target과 가장 근접한 수를 찾는 것

처음 문제를 봤을때 Greedy & Two Pointer 문제가 아닐까 했지만 머릿속에 떠오른 반례들 때문에 o(n^3)이 최선으로 떠올랐다.

이를 O(N^2)으로 투포인터와 같이 풀기 위해서는 숫자 x 에 대하여 가장 작은 수 + 가장 큰 수의 합이 타겟에 근접했는가에 대하여 left, right를 줄여가며 그 합의 차가 가장 작은것을 반환한다.

Keywords: Greedy, Two Pointer, Sorting

## 2019-10-01

### 567 (Two pointer, String)

#### 석호

문제요약

s1을 순열로 만들었을때 s2의 substring에 존재하는지 체크하고 만약 존재한다면 True를 반환하시오.

나는 이 문제를 Twopinter, Sliding Winndow 기법으로 접근했다. 최종적인 시간복잡도는 O(N).

이 문제는 순열을 직접 다 만들 필요가 없다. 구간에 그 숫자가 존재하는가? 에 대해 확인하는 과정만 잘 처리하면 순열을 만드는 O(!N)의 수고를 덜 수 있다.

Keywords: Two pointer, String, Sliding Window

#### 윤수 

딕셔너리를 쓸 필요 없이 배열을 사용해서 처리하는 게 더 효율적이라고 생각한다. 
조금 더 빠르게 풀 수 있다. 

## 2019-10-10

### 1177 (mapping, string)

#### 세진

- **문제를 정확히 읽자**

    출제자가 볼드 처리까지 해놨으면 좀 봐주도록 하자.

    문제를 빨리 파악하기 위해 테스트케이스부터 보는 건 좋지만, 테스트케이스를 이해했으면 빼먹은 조건이 없는지 문제를 다시 읽어보자.

- **맘대로 문제를 바꾸지 말자**

    문제에서 주어진 문자열을 반 자르라는 얘기는 그 어디에도 없었다. 따라서 재배열은 문자열의 그 어느 부분이라도 가능하다.

    문제를 풀기 위해 사용한 도구가 문제의 조건인 것처럼 해석하지 말자.

- **재배열 쌉가능**

    이란 조건이 붙어있으면 결국 존재 여부, 또는 갯수만 확인하면 된다. 가능한 접근은 2개 정도가 있을텐데..

    1. 정렬해놓고 시작하기

        O(NlogN)이 걸린다. 이 유형에서는 별로 좋은 생각이 아니다.

    2. **해시맵**

        갯수만 카운트하기 때문에 O(N)으로 끝내버릴 수 있다.