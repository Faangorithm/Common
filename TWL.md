# Today We Learned

## 2019-09-27(Fri)
### 16 (Two pointer)
#### 윤수 
- 요약 : 하나의 고정점을 찾는 3개의 포인터 이동 문제다.  
투 포인터 문제는 각각의 포인터를 왼쪽끝과 오른쪽끝에서 시작해 한 스텝에 무조건 둘 중 하나의 포인터를 이동시켜 더 작은 범위를 만들어야 한다.   
정렬을 함으로써 왼쪽 끝과 오른쪽 끝을 포인터로 시작할 수 있게된다.   
3개의 자유 변수를 1개의 자유 변수, 1개의 커지는 변수(왼쪽 포인터), 1개의 작아지는 변수(오른쪽 포인터)로 제약을 걸게 되면 O(n^2)로 풀 수 있다.   

### 16 (Two Pointer)
#### 석호

문제 요약: target이 주어지고 세 수의 합이 target과 가장 근접한 수를 찾는 것

처음 문제를 봤을때 Greedy & Two Pointer 문제가 아닐까 했지만 머릿속에 떠오른 반례들 때문에 o(n^3)이 최선으로 떠올랐다.

이를 O(N^2)으로 투포인터와 같이 풀기 위해서는 숫자 x 에 대하여 가장 작은 수 + 가장 큰 수의 합이 타겟에 근접했는가에 대하여 left, right를 줄여가며 그 합의 차가 가장 작은것을 반환한다.

Keywords: Greedy, Two Pointer, Sorting

## 2019-10-01

### 567 (Two pointer, String)

#### 석호

문제요약

s1을 순열로 만들었을때 s2의 substring에 존재하는지 체크하고 만약 존재한다면 True를 반환하시오.

나는 이 문제를 Twopinter, Sliding Winndow 기법으로 접근했다. 최종적인 시간복잡도는 O(N).

이 문제는 순열을 직접 다 만들 필요가 없다. 구간에 그 숫자가 존재하는가? 에 대해 확인하는 과정만 잘 처리하면 순열을 만드는 O(!N)의 수고를 덜 수 있다.

Keywords: Two pointer, String, Sliding Window

#### 윤수 

딕셔너리를 쓸 필요 없이 배열을 사용해서 처리하는 게 더 효율적이라고 생각한다. 
조금 더 빠르게 풀 수 있다. 


## 2019-10-10

### 1177 (Mapping, String, Prefix sum, Heuristic)

#### 석호

문제요약: 구간에서 재배치를 통해 회문을 만드시오 단 k 개 이하의 알파뱃은 임의로 수정할 수 있음.

문제이해시간의 중요성을 다시금 알게 된 모임이었다.

나는 replace를 대충 봐서 remove로 생각했었고

서로 문제를 확인하는 시간을 제대로 가지지 못하여 Rearrange라는 단어 자체를 무시했다.

즉, 전혀 다른 문제를 풀고 있었음.

문제 이해 후 Approach를 떠올려 보는 것에는 크게 문제가 없었다. 하지만 Meeting 시간에 구현하지 못한 것은 반성해야 할 것 같다. (1시간 30분가량 다른 문제 풀고 있었음.) 

Approach는 **Rearrange** 라는 단어를 통해 순서가 의미가 없어진다는 점에서 착안하여 문자의 개수를 통해 문제를 풀려고 하였다. 시간복잡도는 O(N)

하지만 O(N) 으론 문제가 풀리지 않는다. 왜냐면 인풋의 크기가 크기 때문 쿼리당 O(1)을 만들어야 하거나 아주 작게 만들어야한다. 나는 여기서 휴리스틱하게 중복되는 연산의 횟수를 크게 줄이기 위해 블럭단위로 미리 계산해두었다. 

다른 방법으로는 prefix sum이 있는데 재밌는 사실을 잊고 있었다. 누적합을 가지고 있는 배열에 대하여 right+1 - left 는 그 구간의 합과 같다는 사실을 사용하면 누적합만 구해놓는다면 매 쿼리당 O(1) 즉 상수시간에 구간합을 구할 수 있다. 누적합 구하는데는 O(N) 하지만 이는 쿼리의 수랑 무관하기 때문에 prefix sum 솔루션은 O(N)이 된다.

하지만 휴리스틱한 방법은 경험적으로 그리고 실험적으로 적용해보아야 하기 때문에 인풋의 사이즈가 제한이 없다면 사용하기 어렵고, 컨테스트였다면 점수 왕창 까졌을 것 이다.

#### 세진

- **문제를 정확히 읽자**

    출제자가 볼드 처리까지 해놨으면 좀 봐주도록 하자.

    문제를 빨리 파악하기 위해 테스트케이스부터 보는 건 좋지만, 테스트케이스를 이해했으면 빼먹은 조건이 없는지 문제를 다시 읽어보자.

- **맘대로 문제를 바꾸지 말자**

    문제에서 주어진 문자열을 반 자르라는 얘기는 그 어디에도 없었다. 따라서 재배열은 문자열의 그 어느 부분이라도 가능하다.

    문제를 풀기 위해 사용한 도구가 문제의 조건인 것처럼 해석하지 말자.

- **재배열 쌉가능**

    이란 조건이 붙어있으면 결국 존재 여부, 또는 갯수만 확인하면 된다. 가능한 접근은 2개 정도가 있을텐데..

    1. 정렬해놓고 시작하기

        O(NlogN)이 걸린다. 이 유형에서는 별로 좋은 생각이 아니다.

    2. **해시맵**

        갯수만 카운트하기 때문에 O(N)으로 끝내버릴 수 있다.

- **투포인터 vs 부분합**

    두 문제 유형은 매우 비슷하게 생겼지만 결정적인 차이가 있다. 두개의 포인터가 어떤 방향성을 가지고 순서대로 움직인다면 투포인터 문제라고 볼 수 있다. 반면, 부분합 문제의 경우 아무 방향성이 없이 랜덤하게 두 개의 포인터가 결정된다.