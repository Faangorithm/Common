# Today We Learned

## 2019-09-27(Fri)
### 16 (Two pointer)
#### 윤수 
- 요약 : 하나의 고정점을 찾는 3개의 포인터 이동 문제다.  
투 포인터 문제는 각각의 포인터를 왼쪽끝과 오른쪽끝에서 시작해 한 스텝에 무조건 둘 중 하나의 포인터를 이동시켜 더 작은 범위를 만들어야 한다.   
정렬을 함으로써 왼쪽 끝과 오른쪽 끝을 포인터로 시작할 수 있게된다.   
3개의 자유 변수를 1개의 자유 변수, 1개의 커지는 변수(왼쪽 포인터), 1개의 작아지는 변수(오른쪽 포인터)로 제약을 걸게 되면 O(n^2)로 풀 수 있다.   

### 16 (Two Pointer)
#### 석호

문제 요약: target이 주어지고 세 수의 합이 target과 가장 근접한 수를 찾는 것

처음 문제를 봤을때 Greedy & Two Pointer 문제가 아닐까 했지만 머릿속에 떠오른 반례들 때문에 o(n^3)이 최선으로 떠올랐다.

이를 O(N^2)으로 투포인터와 같이 풀기 위해서는 숫자 x 에 대하여 가장 작은 수 + 가장 큰 수의 합이 타겟에 근접했는가에 대하여 left, right를 줄여가며 그 합의 차가 가장 작은것을 반환한다.

Keywords: Greedy, Two Pointer, Sorting

## 2019-10-01

### 567 (Two pointer, String)

#### 석호

문제요약

s1을 순열로 만들었을때 s2의 substring에 존재하는지 체크하고 만약 존재한다면 True를 반환하시오.

나는 이 문제를 Twopinter, Sliding Winndow 기법으로 접근했다. 최종적인 시간복잡도는 O(N).

이 문제는 순열을 직접 다 만들 필요가 없다. 구간에 그 숫자가 존재하는가? 에 대해 확인하는 과정만 잘 처리하면 순열을 만드는 O(!N)의 수고를 덜 수 있다.

Keywords: Two pointer, String, Sliding Window

#### 윤수 

딕셔너리를 쓸 필요 없이 배열을 사용해서 처리하는 게 더 효율적이라고 생각한다. 
조금 더 빠르게 풀 수 있다. 


## 2019-10-10

### 1177 (Mapping, String, Prefix sum, Heuristic)

#### 석호

문제요약: 구간에서 재배치를 통해 회문을 만드시오 단 k 개 이하의 알파뱃은 임의로 수정할 수 있음.

문제이해시간의 중요성을 다시금 알게 된 모임이었다.

나는 replace를 대충 봐서 remove로 생각했었고

서로 문제를 확인하는 시간을 제대로 가지지 못하여 Rearrange라는 단어 자체를 무시했다.

즉, 전혀 다른 문제를 풀고 있었음.

문제 이해 후 Approach를 떠올려 보는 것에는 크게 문제가 없었다. 하지만 Meeting 시간에 구현하지 못한 것은 반성해야 할 것 같다. (1시간 30분가량 다른 문제 풀고 있었음.) 

Approach는 **Rearrange** 라는 단어를 통해 순서가 의미가 없어진다는 점에서 착안하여 문자의 개수를 통해 문제를 풀려고 하였다. 시간복잡도는 O(N)

하지만 O(N) 으론 문제가 풀리지 않는다. 왜냐면 인풋의 크기가 크기 때문 쿼리당 O(1)을 만들어야 하거나 아주 작게 만들어야한다. 나는 여기서 휴리스틱하게 중복되는 연산의 횟수를 크게 줄이기 위해 블럭단위로 미리 계산해두었다. 

다른 방법으로는 prefix sum이 있는데 재밌는 사실을 잊고 있었다. 누적합을 가지고 있는 배열에 대하여 right+1 - left 는 그 구간의 합과 같다는 사실을 사용하면 누적합만 구해놓는다면 매 쿼리당 O(1) 즉 상수시간에 구간합을 구할 수 있다. 누적합 구하는데는 O(N) 하지만 이는 쿼리의 수랑 무관하기 때문에 prefix sum 솔루션은 O(N)이 된다.

하지만 휴리스틱한 방법은 경험적으로 그리고 실험적으로 적용해보아야 하기 때문에 인풋의 사이즈가 제한이 없다면 사용하기 어렵고, 컨테스트였다면 점수 왕창 까졌을 것 이다.

#### 세진

- **문제를 정확히 읽자**

    출제자가 볼드 처리까지 해놨으면 좀 봐주도록 하자.

    문제를 빨리 파악하기 위해 테스트케이스부터 보는 건 좋지만, 테스트케이스를 이해했으면 빼먹은 조건이 없는지 문제를 다시 읽어보자.

- **맘대로 문제를 바꾸지 말자**

    문제에서 주어진 문자열을 반 자르라는 얘기는 그 어디에도 없었다. 따라서 재배열은 문자열의 그 어느 부분이라도 가능하다.

    문제를 풀기 위해 사용한 도구가 문제의 조건인 것처럼 해석하지 말자.

- **재배열 쌉가능**

    이란 조건이 붙어있으면 결국 존재 여부, 또는 갯수만 확인하면 된다. 가능한 접근은 2개 정도가 있을텐데..

    1. 정렬해놓고 시작하기

        O(NlogN)이 걸린다. 이 유형에서는 별로 좋은 생각이 아니다.

    2. **해시맵**

        갯수만 카운트하기 때문에 O(N)으로 끝내버릴 수 있다.

- **투포인터 vs 부분합**

    두 문제 유형은 매우 비슷하게 생겼지만 결정적인 차이가 있다. 두개의 포인터가 어떤 방향성을 가지고 순서대로 움직인다면 투포인터 문제라고 볼 수 있다. 반면, 부분합 문제의 경우 아무 방향성이 없이 랜덤하게 두 개의 포인터가 결정된다.


## 2019-10-13(Sun)
### 481 (String)

#### 윤수 
- **1과 2 토글시키는 방법**
if문이나 3항 연산자 사용하지 않고도 toggle ^= 3을 사용해서 토글시킬 수 있음.

- **git reset --hard upstream/master**
석호가 업스트림을 자기 마음대로 바꾸었을 경우 포크된 레포에서 사용. 

#### 석호

**문제 독해 능력을 기르자**

빠르게 읽을수록 풀 수 있는 시간이 더 늘어난다!

**간단하게 생각하자**

구현을 좀더 간결하게 할 필요가 있다.

**잘했다! 풀이하나에 집착하지 않았다!**

O(1)이 있을꺼라고 생각하며 그쪽을 팠으면 그대로 틀렸을것


## 2019-10-18(Fri)
### 722 (String)

#### 석호

1. **간단하게 생각했어야**

    문제를 보자마자 파싱이 떠올랐고, 오토마타로 풀면 되겠다는 생각을 했다. 하지만 이런 문제수준에서는 오토마타까지 구성할 필요는 없을 수도 있다.

2. **키보드 먼저 잡는 습관을 고치자**

    내 어프로치는 오토마타이고 오토마타는 깊이 고민을 하며 규칙을 완전히 만들고 구현해야 한다. 막 구현하기 시작하면 계속 꼬일 수 밖에 없고 이는 문제 해결과는 거리가 멀어진다.

3. **임기응변이라고 생각되면 잠시 멈추고 정리하자**

    코드가 길어지거나 머릿속이 복잡할수록 한가지 케이스 혹은 하나의 경우를 피하기 급급한 경우가 있다. 코드의 퀄리티도 현저히 떨어지고 상태도 이상해진다. 여기에 방향까지 이상하면 문제를 못푼다.
    
4. **쉽게 생각하자**

    오토마타 말고 다른거도 생각 할 수 있었는데..

오토마타를 적용하여 이 문제를 풀기는 그렇게 어렵지 않다.

각 상태에 대하여 전이되는 것 만 잘 파악해야 하는것이 중요하다.

다음은 이번 문제를 풀기 위한 오토마타를 구성했고 그것을 가시화 한 것이다.

![image](https://user-images.githubusercontent.com/18409763/67138377-1d6c9580-f27d-11e9-81c2-a2df760c5665.png)

이를 코드로 옮긴 것이 이번 문제의 해답이 된다.
#### 윤수
1. **git을 대충쓰지 말자** 
커밋을 하나로 합쳐서 올리고, 깃 로그를 잘 살피자


## 2019-10-31(Thurs)
### 670 

#### 윤수 
1. git reset --hard upstream/master를 쓰기 전에 git fetch upstream/master를 사용해서 fetch를 시키자.

#### 석호

1. 구현때 실수하지 말자. Codeforce 였으면 두번쯤은 Wrong Answer 났을듯

2. 사실 N=8 이라 N^2 이여도 64번 반복한다 어찌보면 8x3 vs 8x8 정도의 수준이였을듯.

3. 그래도 입력이 string 형태의 거대한 숫자였다면 N으로 풀어야 풀 수 있었을 수도 있음.

4. 문제 풀이 유형인지 정확히 파악하자 (메모이제이션, DP 등)

#### 세진

- **N이 작아도 다시 보자**

    N=8 밖에 안 돼서 O(N^2)으로도 해결할 수 있는 문제였지만 더 생각해서 O(N)으로 줄일 수 있었다.

## 2019-11-06(Wed)
### 134(PartialSum)

#### 윤수 
1. **구간 범위 잘 생각하자**
[start, end)를 선호하자
2. **(i + j) % n**으로 범위를 줄이자



## 2019-11-13(Wed)
### 148
#### 윤수 
1. **merge sort** 
링크드 리스트를 정렬할 때 머지 소트를 적용할 수 있다는 발상을 하자


### 935

#### 윤수 
1. **Dp 문제**
dp 문제는 바텀업으로 풀면 더 빠르다. 근데 왜 더 느릴까?

#### 석호
1. **DP**
릿코드에서 첫 DP 문제. 점화식의 초깃값을 잘못 줘서 구현에 시간 좀 더 썼다. 그래도 빠르게 해결한 편인듯.

#### 우찬
1. dp의 개념을 잘 파악하자
2. dp 기본 문제들을 많이 풀어보자

### 991

#### 우찬
1. 거꾸로 생각했을때 쉽게 풀 수 있는 방법을 항상 먼저 생각해보자
